<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Подбор трековой системы</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Подключаем библиотеки для создания PDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
  <style>
    /* Стили для всей страницы */
    body {
      font-family: Arial, sans-serif;
      background-color: #e7f5fd;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    /* Левая область: форма выбора */
    .form-container {
      flex: 1 1 300px;
      background-color: white;
      padding: 20px;
      border: 1px solid #ddd;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      box-sizing: border-box;
      max-width: 350px;
    }
    .form-container h2 {
      font-size: 18px;
      margin-bottom: 10px;
    }
    .form-container label {
      display: block;
      margin-top: 10px;
      font-size: 14px;
    }
    .form-container select,
    .form-container input[type="text"] {
      width: 100%;
      padding: 8px;
      margin-top: 5px;
      font-size: 14px;
      box-sizing: border-box;
    }
    .shape-options {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }
    .shape-options div {
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 1px solid #ddd;
      padding: 5px;
      border-radius: 5px;
      background-color: #f9f9f9;
      width: calc(50% - 5px);
      box-sizing: border-box;
    }
    .shape-options img {
      width: 50px;
      height: auto;
    }
    .shape-options label {
      font-size: 12px;
      margin-top: 5px;
      text-align: center;
    }
    /* Группа для ввода длин и кнопки добавления светильников */
    .input-group {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 15px;
    }
    .input-group > div {
      flex: 1;
    }
    .input-group input[type="text"] {
      width: 100%;
      padding: 8px;
      font-size: 14px;
      box-sizing: border-box;
    }
    /* Кнопка "Добавить светильник" – меньшего размера и выровнена по центру вертикально */
    .add-lighting-button {
      width: 120px;
      padding: 5px 10px;
      font-size: 12px;
      cursor: pointer;
      text-align: center;
    }
    /* Кнопка "Подобрать" располагается ниже остальных элементов */
    .button-container {
      margin-top: 20px;
    }
    .button-container button {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    /* Правая область: блок с производителями – столбцы занимают всю высоту страницы */
    .manufacturers-container {
      flex: 2 1 500px;
      display: none;
      flex-wrap: wrap;
      gap: 10px;
    }
    .manufacturer-column {
      flex: 1 1 calc(20% - 10px);
      background-color: white;
      border: 1px solid #ddd;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .manufacturer-title {
      background-color: #f4f4f4;
      padding: 5px;
      text-align: center;
      font-weight: bold;
      border-bottom: 1px solid #ddd;
      font-size: 14px;
    }
    .manufacturer-iframe {
      flex: 1;
      border: none;
      width: 100%;
    }
    .download-pdf-button {
      width: 100%;
      padding: 5px;
      font-size: 12px;
      cursor: pointer;
      background-color: #eee;
      border: 1px solid #ccc;
      margin-top: 5px;
    }
    .debug {
      margin-top: 10px;
      font-size: 12px;
      color: red;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Левая область: форма выбора -->
    <div class="form-container">
      <h2>Подбор трековой системы</h2>
      <label for="type">Тип:</label>
      <select id="type" name="type">
        <option value="one-phase">Однофазный</option>
        <option value="magnetic">Магнитный</option>
      </select>
      <label for="color">Цвет:</label>
      <select id="color" name="color">
        <option value="black">Черный</option>
        <option value="white">Белый</option>
      </select>
      <label for="mounting">Способ монтажа:</label>
      <select id="mounting" name="mounting">
        <option value="surface">Накладной</option>
        <option value="recessed">Встраиваемый</option>
        <option value="stretch-ceiling">В натяжной потолок</option>
        <option value="hanging">Подвесной</option>
      </select>
      <label>Фигура:</label>
      <div class="shape-options">
        <div>
          <img src="images/straight.png" alt="Прямая">
          <input type="radio" id="straight" name="shape" value="straight" onclick="selectShape('straight')">
          <label for="straight">Прямая</label>
        </div>
        <div>
          <img src="images/L-shape.png" alt="L-образная">
          <input type="radio" id="L-shape" name="shape" value="L-shape" onclick="selectShape('L-shape')">
          <label for="L-shape">L-образная</label>
        </div>
        <div>
          <img src="images/T-shape.png" alt="T-образная">
          <input type="radio" id="T-shape" name="shape" value="T-shape" onclick="selectShape('T-shape')">
          <label for="T-shape">T-образная</label>
        </div>
        <div>
          <img src="images/P-shape.png" alt="П-образная">
          <input type="radio" id="P-shape" name="shape" value="P-shape" onclick="selectShape('P-shape')">
          <label for="P-shape">П-образная</label>
        </div>
        <div>
          <img src="images/rectangle.png" alt="Прямоугольник">
          <input type="radio" id="rectangle" name="shape" value="rectangle" onclick="selectShape('rectangle')">
          <label for="rectangle">Прямоугольник</label>
        </div>
        <div>
          <img src="images/x.png" alt="Х-образная">
          <input type="radio" id="x" name="shape" value="x" onclick="selectShape('x')">
          <label for="x">Х‑образная</label>
        </div>
      </div>
      <input type="hidden" id="selectedShape" name="selectedShape" value="">
      <!-- Группа для ввода длин и кнопки "Добавить светильник" -->
      <div class="input-group">
        <div>
          <label for="lengthA">Длина а (см):</label>
          <input type="text" id="lengthA" name="lengthA" placeholder="Длина а">
        </div>
        <div>
          <label for="lengthB">Длина б (см):</label>
          <input type="text" id="lengthB" name="lengthB" placeholder="Длина б">
        </div>
        <div>
          <button type="button" class="add-lighting-button" onclick="addLightingRow()">Добавить светильник</button>
        </div>
      </div>
      <!-- Контейнер для динамических строк выбора светильников -->
      <div id="lightingButtonsContainer"></div>
      <!-- Кнопка "Подобрать" -->
      <div class="button-container">
        <button type="button" onclick="safeShowSelection()">Подобрать</button>
      </div>
      <div id="debug" class="debug"></div>
    </div>

    <!-- Правая область: блок с производителями -->
    <div class="manufacturers-container" id="manufacturersContainer">
      <!-- Столбцы производителей будут создаваться динамически -->
    </div>
  </div>

  <script>
    // Функция для установки выбранной фигуры
    function selectShape(shape) {
      document.getElementById("selectedShape").value = shape;
      console.log("Выбрана фигура:", shape);
    }

    // Функции для работы со строками выбора светильников
    let lightingRowsCount = 0;
    const maxLightingRows = 3;
    function addLightingRow() {
      if (lightingRowsCount >= maxLightingRows) {
        alert("Можно добавить не более " + maxLightingRows + " вариантов светильников.");
        return;
      }
      lightingRowsCount++;
      // Собираем уже выбранные варианты, чтобы исключить их из списка
      const selectedValues = [];
      const existingSelects = document.querySelectorAll("[id^='light']");
      existingSelects.forEach(select => {
        if (select.value) {
          selectedValues.push(select.value);
        }
      });
      const allOptions = [
        { value: "spot", text: "Как споты" },
        { value: "linear", text: "Линейный" },
        { value: "pendant", text: "Подвесной" }
      ];
      const availableOptions = allOptions.filter(opt => !selectedValues.includes(opt.value));
      if (availableOptions.length === 0) {
        alert("Все варианты светильников уже выбраны.");
        return;
      }
      let selectHTML = `<select id="light${lightingRowsCount}" name="light${lightingRowsCount}">`;
      availableOptions.forEach(opt => {
        selectHTML += `<option value="${opt.value}">${opt.text}</option>`;
      });
      selectHTML += `</select>`;
      const container = document.createElement("div");
      container.className = "lighting-row";
      container.id = "lightingRow" + lightingRowsCount;
      container.innerHTML = `
        ${selectHTML}
        <div class="quantity-controls">
          <button type="button" onclick="decreaseQuantity('light${lightingRowsCount}')">-</button>
          <input type="number" id="quantity${lightingRowsCount}" name="quantity${lightingRowsCount}" value="1" min="1" style="width: 60px;">
          <button type="button" onclick="increaseQuantity('light${lightingRowsCount}')">+</button>
        </div>
        <button type="button" class="remove-button" onclick="removeLightingRow('lightingRow${lightingRowsCount}')">Удалить</button>
      `;
      document.getElementById("lightingButtonsContainer").appendChild(container);
      console.log("Добавлена строка выбора светильника.");
    }
    
    function increaseQuantity(lightId) {
      const quantityInput = document.getElementById("quantity" + lightId.slice(-1));
      quantityInput.value = parseInt(quantityInput.value) + 1;
    }
    
    function decreaseQuantity(lightId) {
      const quantityInput = document.getElementById("quantity" + lightId.slice(-1));
      if (parseInt(quantityInput.value) > 1) {
        quantityInput.value = parseInt(quantityInput.value) - 1;
      }
    }
    
    function removeLightingRow(rowId) {
      const row = document.getElementById(rowId);
      row.parentNode.removeChild(row);
      lightingRowsCount--;
      console.log("Удалена строка выбора светильника.");
    }
    
    // Дополнительное сопоставление производителей для разных типов систем
    const manufacturersData = {
      "one-phase": [
        { title: "Maytoni UNITY", file: "maytoni.html" },
        { title: "NOVOTECH", file: "novotech.html" },
        { title: "ST LUCE", file: "st_luce.html" },
        { title: "AMBRELA", file: "ambrela.html" },
        { title: "DENKIRS", file: "denkirs.html" }
      ],
      "magnetic": [
        { title: "Maytoni S35", file: "maytoni_s35.html" },
        { title: "Maytoni EXILITY", file: "maytoni_exility.html" },
        { title: "ST LUCE 220", file: "st_luce_220.html" },
        { title: "ST LUCE 48", file: "st_luce_48.html" },
        { title: "DENKIRS 220", file: "denkirs_220.html" }
      ]
    };
    
    // Функция обновления iframe для производителей
    function updateManufacturerIframes(queryString, manufacturerList) {
      const container = document.getElementById("manufacturersContainer");
      container.innerHTML = ""; // Очистка предыдущих столбцов
      manufacturerList.forEach(man => {
        const col = document.createElement("div");
        col.className = "manufacturer-column";
        // Имя PDF-файла: то же имя, что и HTML (расширение .pdf)
        const pdfFile = man.file.replace(/\.html$/i, ".pdf");
        col.innerHTML = `
          <div class="manufacturer-title">${man.title}</div>
          <iframe class="manufacturer-iframe" id="iframe-${man.title}" src="${man.file + queryString}"></iframe>
          <button class="download-pdf-button" onclick="downloadPDF('${man.title}', '#iframe-${man.title}')">Скачать PDF</button>
        `;
        container.appendChild(col);
      });
    }
    
    // Функция для скачивания PDF с выбранными товарами (используются html2canvas и jsPDF)
    function downloadPDF(manufacturerTitle, iframeSelector) {
      const iframe = document.querySelector(iframeSelector);
      if (!iframe) {
        alert("Ошибка: не найден iframe для " + manufacturerTitle);
        return;
      }
      const iframeDoc = iframe.contentWindow.document;
      const resultsTable = iframeDoc.getElementById("resultsTable");
      if (!resultsTable) {
        alert("Ошибка: не найдена таблица с товарами для " + manufacturerTitle);
        return;
      }
      html2canvas(resultsTable, { scale: 2 }).then(canvas => {
        const imgData = canvas.toDataURL("image/png");
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF("p", "mm", "a4");
        const imgWidth = 190;
        const imgHeight = (canvas.height * imgWidth) / canvas.width;
        pdf.text(manufacturerTitle, 10, 10);
        pdf.addImage(imgData, "PNG", 10, 20, imgWidth, imgHeight);
        pdf.save(manufacturerTitle + "_выбор.pdf");
      });
    }
    
    // Функция обновления параметров формы и отображения результата (вызывается при нажатии "Подобрать")
    function safeShowSelection() {
      try {
        const type = document.getElementById("type").value;
        const color = document.getElementById("color").value;
        const mounting = document.getElementById("mounting").value;
        const shape = document.getElementById("selectedShape").value;
        const lengthA = encodeURIComponent(document.getElementById("lengthA").value.trim());
        const lengthB = encodeURIComponent(document.getElementById("lengthB").value.trim());
        const queryString = `?type=${type}&color=${color}&mounting=${mounting}&shape=${shape}&lengthA=${lengthA}&lengthB=${lengthB}`;
        console.log("Query-string:", queryString);
        const manufacturerList = manufacturersData[type] || [];
        if (manufacturerList.length === 0) {
          document.getElementById("debug").textContent = "Производители для выбранного типа не заданы.";
          return;
        }
        updateManufacturerIframes(queryString, manufacturerList);
        document.getElementById("manufacturersContainer").style.display = "flex";
        document.getElementById("debug").textContent = "";
      } catch (e) {
        console.error("Ошибка в safeShowSelection:", e);
        alert("Произошла ошибка при подборе. Проверьте консоль для подробностей.");
      }
    }
    
    /***** Дополнительные данные для светильников (Maytoni) *****/
    var lightingMappingMaytoni = {
      "spot": {
        "black": { id: "TR020-1-GU10-B", name: "Трековый светильник Focus S черный", price: 1690, image: "images/maytoni unity/TR020-1-GU10-B.png" },
        "white": { id: "TR020-1-GU10-W", name: "Трековый светильник Focus S белый", price: 1690, image: "images/maytoni unity/TR020-1-GU10-W.png" }
      },
      "linear": {
        "black": { id: "TR000-1-12W4K-B", name: "Линейный светильник черный (12w 4000K)", price: 4390, image: "images/maytoni unity/TR000-1-12W4K-B.png" },
        "white": { id: "TR000-1-12W4K-W", name: "Линейный светильник белый (12w 4000K)", price: 4390, image: "images/maytoni unity/TR000-1-12W4K-W.png" }
      },
      "pendant": {
        "black": { id: "TR025-1-GU10-B", name: "Подвесной светильник черный", price: 2590, image: "images/maytoni unity/TR025-1-GU10-B.png" },
        "white": { id: "TR008-1-GU10-W", name: "Подвесной светильник белый", price: 2600, image: "images/maytoni unity/TR008-1-GU10-W.png" }
      }
    };
    
    /***** Функции расчёта трековых сегментов *****/
    function getTracksForMaytoniSurface(legLength, lengthOptions) {
      let pieces = [];
      if (legLength % 400 === 0) {
        let count = legLength / 200;
        for (let i = 0; i < count; i++) {
          pieces.push({ id: lengthOptions[1].items[0], pieceLength: 200 });
        }
        return pieces;
      }
      if (legLength <= 100) {
        pieces.push({ id: lengthOptions[0].items[0], pieceLength: 100 });
      } else if (legLength <= 200) {
        pieces.push({ id: lengthOptions[1].items[0], pieceLength: 200 });
      } else if (legLength <= 300) {
        pieces.push({ id: lengthOptions[2].items[0], pieceLength: 300 });
      } else {
        let fullPieces = Math.floor(legLength / 300);
        for (let i = 0; i < fullPieces; i++) {
          pieces.push({ id: lengthOptions[2].items[0], pieceLength: 300 });
        }
        let remainder = legLength - fullPieces * 300;
        if (remainder > 0) {
          if (remainder <= 100) {
            pieces.push({ id: lengthOptions[0].items[0], pieceLength: 100 });
          } else if (remainder <= 200) {
            pieces.push({ id: lengthOptions[1].items[0], pieceLength: 200 });
          } else {
            pieces.push({ id: lengthOptions[2].items[0], pieceLength: 300 });
          }
        }
      }
      return pieces;
    }
    function getTracksForMaytoniRecessed(legLength, lengthOptions) {
      let pieces = [];
      if (legLength % 400 === 0) {
        let count = legLength / 200;
        for (let i = 0; i < count; i++) {
          pieces.push({ id: lengthOptions[1].items[0], pieceLength: 200 });
        }
        return pieces;
      }
      if (legLength <= 100) {
        pieces.push({ id: lengthOptions[0].items[0], pieceLength: 100 });
      } else if (legLength <= 200) {
        pieces.push({ id: lengthOptions[1].items[0], pieceLength: 200 });
      } else {
        let fullPieces = Math.floor(legLength / 200);
        for (let i = 0; i < fullPieces; i++) {
          pieces.push({ id: lengthOptions[1].items[0], pieceLength: 200 });
        }
        let remainder = legLength - fullPieces * 200;
        if (remainder > 0) {
          if (remainder <= 100) {
            pieces.push({ id: lengthOptions[0].items[0], pieceLength: 100 });
          } else {
            pieces.push({ id: lengthOptions[1].items[0], pieceLength: 200 });
          }
        }
      }
      return pieces;
    }
    
    function getNominalLength(id) {
      if (id.indexOf("-111") !== -1) return 100;
      if (id.indexOf("-112") !== -1) return 200;
      if (id.indexOf("-113") !== -1) return 300;
      return null;
    }
    
    function wrapConnector(conn) {
      return (typeof conn === "object" && conn !== null && conn.id !== undefined) ? conn : { id: conn };
    }
    
    window.safeShowSelection = function() {
      try {
        showSelection();
      } catch (e) {
        console.error("Ошибка в showSelection:", e);
        alert("Произошла ошибка при подборе. Проверьте консоль для подробностей.");
      }
    };
    
    /***** Основная функция подбора для Maytoni *****/
    window.showSelection = function() {
      console.log("Начало работы showSelection (Maytoni)");
      const params = new URLSearchParams(window.location.search);
      const type = params.get("type") || "one-phase";
      const color = params.get("color") || "black";
      let mountingParam = params.get("mounting") || "surface";
      const shape = params.get("shape") || "straight";
      const lengthA = parseFloat(params.get("lengthA")) || 150;
      const lengthB = parseFloat(params.get("lengthB")) || 0;
      console.log("Параметры подбора:", { type, color, mounting: mountingParam, shape, lengthA, lengthB });
      
      let effectiveProduct = (mountingParam === "stretch-ceiling" || mountingParam === "hanging") ?
          (products[type] && products[type][color] && products[type][color]["surface"]) :
          (products[type] && products[type][color] && products[type][color][mountingParam]);
      if (!effectiveProduct) {
        throw new Error("Не найден комплект для выбранных параметров (effectiveProduct).");
      }
      
      let components = effectiveProduct.components;
      if (mountingParam === "stretch-ceiling") {
        const ceilingProduct = products[type][color]["stretch-ceiling"];
        if (ceilingProduct && ceilingProduct.components) {
          components = Object.assign({}, components, ceilingProduct.components);
        }
      }
      
      const lengthOptions = effectiveProduct.lengthOptions;
      let selectedItems = [];
      let usedConnectors = [];
      
      // Расчёт трековых сегментов в зависимости от выбранной фигуры
      if (shape === "straight") {
        selectedItems = (mountingParam === "recessed") ?
                        getTracksForMaytoniRecessed(lengthA, lengthOptions) :
                        getTracksForMaytoniSurface(lengthA, lengthOptions);
      }
      else if (shape === "L-shape") {
        let legATracks = (mountingParam === "recessed") ?
                         getTracksForMaytoniRecessed(lengthA, lengthOptions) :
                         getTracksForMaytoniSurface(lengthA, lengthOptions);
        let legBTracks = (mountingParam === "recessed") ?
                         getTracksForMaytoniRecessed(lengthB, lengthOptions) :
                         getTracksForMaytoniSurface(lengthB, lengthOptions);
        selectedItems = legATracks.concat(legBTracks);
        if (effectiveProduct.connectors["L-shape"] && effectiveProduct.connectors["L-shape"].length > 0) {
          usedConnectors.push(wrapConnector(effectiveProduct.connectors["L-shape"][0]));
        }
        if (legATracks.length > 1) {
          for (let i = 0; i < legATracks.length - 1; i++) {
            usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
          }
        }
        if (legBTracks.length > 1) {
          for (let i = 0; i < legBTracks.length - 1; i++) {
            usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
          }
        }
      }
      else if (shape === "T-shape") {
        let topTracks = (mountingParam === "recessed") ?
                        getTracksForMaytoniRecessed(lengthA, lengthOptions) :
                        getTracksForMaytoniSurface(lengthA, lengthOptions);
        let verticalTracks = (mountingParam === "recessed") ?
                             getTracksForMaytoniRecessed(lengthB, lengthOptions) :
                             getTracksForMaytoniSurface(lengthB, lengthOptions);
        selectedItems = topTracks.concat(verticalTracks);
        if (effectiveProduct.connectors["T-shape"] && effectiveProduct.connectors["T-shape"].length > 0) {
          usedConnectors.push(wrapConnector(effectiveProduct.connectors["T-shape"][0]));
        }
        if (topTracks.length > 1) {
          for (let i = 0; i < topTracks.length - 1; i++) {
            usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
          }
        }
        if (verticalTracks.length > 1) {
          for (let i = 0; i < verticalTracks.length - 1; i++) {
            usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
          }
        }
      }
      else if (shape === "P-shape") {
        let sideTracks = (mountingParam === "recessed") ?
                         getTracksForMaytoniRecessed(lengthA, lengthOptions) :
                         getTracksForMaytoniSurface(lengthA, lengthOptions);
        let connectingTracks = (mountingParam === "recessed") ?
                               getTracksForMaytoniRecessed(lengthB, lengthOptions) :
                               getTracksForMaytoniSurface(lengthB, lengthOptions);
        selectedItems = sideTracks.concat(sideTracks, connectingTracks);
        if (effectiveProduct.connectors["L-shape"] && effectiveProduct.connectors["L-shape"].length > 0) {
          usedConnectors.push(wrapConnector(effectiveProduct.connectors["L-shape"][0]));
          usedConnectors.push(wrapConnector(effectiveProduct.connectors["L-shape"][0]));
        }
        if (sideTracks.length > 1) {
          for (let i = 0; i < sideTracks.length - 1; i++) {
            usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
            usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
          }
        }
        if (connectingTracks.length > 1) {
          for (let i = 0; i < connectingTracks.length - 1; i++) {
            usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
          }
        }
      }
      else if (shape === "rectangle") {
        let tracksA = (mountingParam === "recessed") ?
                      getTracksForMaytoniRecessed(lengthA, lengthOptions) :
                      getTracksForMaytoniSurface(lengthA, lengthOptions);
        let tracksB = (mountingParam === "recessed") ?
                      getTracksForMaytoniRecessed(lengthB, lengthOptions) :
                      getTracksForMaytoniSurface(lengthB, lengthOptions);
        selectedItems = tracksA.concat(tracksA, tracksB, tracksB);
        for (let i = 0; i < 4; i++) {
          usedConnectors.push(wrapConnector(effectiveProduct.connectors["L-shape"][0]));
        }
        let straightForA = (tracksA.length > 1) ? 2 * (tracksA.length - 1) : 0;
        let straightForB = (tracksB.length > 1) ? 2 * (tracksB.length - 1) : 0;
        for (let i = 0; i < straightForA + straightForB; i++) {
          usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
        }
      }
      else if (shape === "x") {
        // X‑образная система: два пересекающихся шинопровода + X‑образный коннектор
        let trackX = (mountingParam === "recessed") ?
                     getTracksForMaytoniRecessed(lengthA, lengthOptions) :
                     getTracksForMaytoniSurface(lengthA, lengthOptions);
        let trackY = (mountingParam === "recessed") ?
                     getTracksForMaytoniRecessed(lengthB, lengthOptions) :
                     getTracksForMaytoniSurface(lengthB, lengthOptions);
        selectedItems = trackX.concat(trackY);
        let xConnector = "";
        if (mountingParam === "recessed") {
          xConnector = (color === "black") ? "TRA002CX-11B" : "TRA002CX-11W";
        } else {
          xConnector = (color === "black") ? "TRA001CX-11B" : "TRA001CX-11W";
        }
        usedConnectors.push(wrapConnector(xConnector));
        if (trackX.length > 1) {
          for (let i = 0; i < trackX.length - 1; i++) {
            usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
          }
        }
        if (trackY.length > 1) {
          for (let i = 0; i < trackY.length - 1; i++) {
            usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
          }
        }
      }
      else {
        throw new Error("Логика для фигуры '" + shape + "' не реализована для Maytoni.");
      }
      
      if (shape === "straight") {
        let trackPieces = selectedItems.filter(item => item.hasOwnProperty("pieceLength"));
        let neededStraight = (trackPieces.length > 1) ? trackPieces.length - 1 : 0;
        let currentStraight = usedConnectors.filter(conn => conn.id === effectiveProduct.connectors.straight[0]).length;
        let missing = neededStraight - currentStraight;
        if (missing > 0) {
          for (let i = 0; i < missing; i++) {
            usedConnectors.push(wrapConnector(effectiveProduct.connectors.straight[0]));
          }
        }
      }
      
      console.log("Подобранные треки (до доп. компонентов):", selectedItems);
      
      /***** Добавление выбранных светильников *****/
      let lightingContainer = document.getElementById("lightingButtonsContainer");
      if (lightingContainer) {
        const lightingRows = lightingContainer.querySelectorAll(".lighting-row");
        lightingRows.forEach(row => {
          let selectEl = row.querySelector("select");
          let qtyEl = row.querySelector("input[type='number']");
          if (selectEl && qtyEl) {
            let lightingType = selectEl.value; // "spot", "linear", "pendant"
            let quantity = parseInt(qtyEl.value) || 1;
            let lightItem = lightingMappingMaytoni[lightingType] ? lightingMappingMaytoni[lightingType][color] : null;
            if (lightItem) {
              for (let i = 0; i < quantity; i++) {
                selectedItems.push({ id: lightItem.id });
                if (!components[lightItem.id]) {
                  components[lightItem.id] = {
                    name: lightItem.name,
                    price: lightItem.price,
                    image: lightItem.image
                  };
                }
              }
            }
          }
        });
      }
      
      /***** Дополнительные компоненты по режимам монтажа *****/
      if (mountingParam === "stretch-ceiling") {
        // Для натяжного потолка – добавляем профиль (рассчитывается по сумме длин трековых сегментов)
        let trackLength = selectedItems.reduce((sum, item) => sum + (item.pieceLength || 0), 0);
        console.log("Общая длина треков (stretch-ceiling):", trackLength, "см");
        let profileCount = Math.ceil(trackLength / 200);
        console.log("Профилей для добавления (stretch-ceiling):", profileCount);
        for (let i = 0; i < profileCount; i++) {
          selectedItems.push({ id: "TRA001MP-112S", pieceLength: 200 });
        }
      }
      else if (mountingParam === "recessed") {
        // Для встраиваемой системы – добавляем профиль для гипсокартонного потолка и заглушки (если система не "rectangle")
        let effectiveTrackLength = 0;
        if (shape === "straight") {
          effectiveTrackLength = lengthA;
        } else if (shape === "L-shape" || shape === "T-shape") {
          effectiveTrackLength = lengthA + lengthB;
        } else if (shape === "P-shape") {
          effectiveTrackLength = 2 * lengthA + lengthB;
        } else if (shape === "rectangle") {
          effectiveTrackLength = 2 * (lengthA + lengthB);
        } else {
          effectiveTrackLength = lengthA + lengthB;
        }
        console.log("Эффективная длина трековой системы (recessed):", effectiveTrackLength, "см");
        let profileCount = Math.ceil(effectiveTrackLength / 200);
        console.log("Профилей для добавления (recessed):", profileCount);
        for (let i = 0; i < profileCount; i++) {
          selectedItems.push({ id: "TR3020-AL", pieceLength: 200 });
        }
        if (shape !== "rectangle") {
          let endCapsCount = (shape === "T-shape") ? 2 : 1;
          let endCapsId = "TR3052-AL"; // для встраиваемых систем заглушка единая
          for (let i = 0; i < endCapsCount; i++) {
            selectedItems.push({ id: endCapsId });
          }
        }
      }
      
      if (mountingParam === "hanging") {
        let effectiveTrackLength = 0;
        if (shape === "straight") {
          effectiveTrackLength = lengthA;
        } else if (shape === "L-shape" || shape === "T-shape") {
          effectiveTrackLength = lengthA + lengthB;
        } else if (shape === "P-shape") {
          effectiveTrackLength = 2 * lengthA + lengthB;
        } else if (shape === "rectangle") {
          effectiveTrackLength = 2 * (lengthA + lengthB);
        } else {
          effectiveTrackLength = lengthA + lengthB;
        }
        console.log("Эффективная длина трековой системы (hanging):", effectiveTrackLength, "см");
        let suspCount = Math.max(2, 1 + Math.ceil(effectiveTrackLength / 200));
        console.log("Подвесов для добавления (hanging):", suspCount);
        let suspensionId = (color === "black") ? "TRA001CW-11B" : "TRA001CW-11W";
        for (let i = 0; i < suspCount; i++) {
          selectedItems.push({ id: suspensionId });
        }
      }
      
      console.log("Финальный результат подбора (Maytoni):", selectedItems);
      
      /***** Группировка элементов *****/
      let groupedItems = {};
      selectedItems.concat(usedConnectors).forEach(itemObj => {
        let id = itemObj.id;
        if (!id) {
          console.warn("Обнаружен элемент без id:", itemObj);
          return;
        }
        let isTrack = itemObj.hasOwnProperty("pieceLength");
        if (!groupedItems[id]) {
          groupedItems[id] = { totalLength: 0, count: 0, component: components[id] || {}, isTrack: isTrack };
        }
        if (isTrack) {
          groupedItems[id].totalLength += itemObj.pieceLength;
        }
        groupedItems[id].count++;
      });
      console.log("Сгруппированные элементы (до расчёта итоговых количеств):", groupedItems);
      
      let totalPrice = 0;
      let tbodyHTML = "";
      for (const [id, group] of Object.entries(groupedItems)) {
        let comp = group.component;
        if (comp && comp.name) {
          let qty;
          if (group.isTrack && group.totalLength > 0) {
            let nominal = getNominalLength(id);
            qty = Math.ceil(group.totalLength / nominal);
          } else {
            qty = group.count;
          }
          let cost = qty * comp.price;
          totalPrice += cost;
          tbodyHTML += `
            <tr>
              <td><img src="images/maytoni unity/${id}.png" alt="${comp.name}" style="width:50px; height:auto; margin-right:10px;">${comp.name} ${id}</td>
              <td style="background-color: white; text-align: center;">${qty} шт.</td>
              <td>${comp.price}₽</td>
              <td>${cost}₽</td>
            </tr>
          `;
        } else {
          console.warn("Компонент с ID " + id + " не найден или не имеет имени.");
        }
      }
      
      document.getElementById("results").innerHTML = tbodyHTML;
      document.getElementById("totalPrice").innerHTML = `<div>Итого: ${totalPrice}₽</div>`;
      document.getElementById("resultContainer").style.display = "block";
      console.log("Подбор завершён успешно (Maytoni).");
    };
    
    document.addEventListener("DOMContentLoaded", function() {
      setTimeout(window.safeShowSelection, 1000);
    });
  </script>
  
  <!-- Контейнер для динамически добавляемых строк выбора светильников -->
  <div id="lightingButtonsContainer"></div>
  
</body>
</html>
